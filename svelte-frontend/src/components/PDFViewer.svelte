<!-- Here we'll run the new script against the upload script -->
<!-- Go to pdf -  
border handle size 

calculate left side of window - 
calculate remainder of right size of window
onclick - listener - track 

console.log - left and right side of line

change action-bar-container -



-->

<script>
	import GenericTable from './GenericTable.svelte';

	import { onMount } from 'svelte';
	import * as pdfjs from 'pdfjs-dist';

	// import { mockResponseJson } from '../data/data.js';
	import { sessionData } from '../store/sessionStore.js';

	let width;
	let height;

	console.log();

	let ocrText = '';
	let pdfDimensions;
	let canvasElement;
	let canvasContainer;
	let words = [];
	let rawWords = []; // Store raw OCR results without scaling
	let uploadedFile;
	let scale = 1;

	// Ensure worker is loaded correctly with Vite
	pdfjs.GlobalWorkerOptions.workerSrc = '/pdf.worker.min.js';

	let nativeWords = [];

	let isOCREnabled = true; // True will show OCR results, False will show native text

	function toggleResults() {
		isOCREnabled = !isOCREnabled;
	}
	console.log('pdf viewer', $sessionData);

	onMount(() => {
		let { pdfBase64 } = $sessionData;

		let decodedPdf = atob(pdfBase64); // Decode Base64 string to character string

		// Convert character string to Uint8Array
		const uint8Array = new Uint8Array(decodedPdf.length);
		for (let i = 0; i < decodedPdf.length; i++) {
			uint8Array[i] = decodedPdf.charCodeAt(i);
		}

		// Convert Uint8Array to Blob
		const uploadedFile = new Blob([uint8Array], { type: 'application/pdf' });
		rawWords = [];
		processPDF(uploadedFile);

		// instead here we will have
		// renderPDF();

		const firstCell = document.querySelector('.entity-table td');
		if (firstCell) {
			firstCell.classList.add('active-cell');
			activeCell = firstCell;
		}
		document.addEventListener('click', (event) => {
			// Hide any tooltip that's currently shown
			const existingTooltip = document.querySelector('.tooltip');
			if (existingTooltip) {
				existingTooltip.remove();
			}
		});

		// Event listener for table cell clicks
		document.querySelectorAll('.entity-table td').forEach((cell) => {
			cell.addEventListener('click', function () {
				if (activeCell) {
					activeCell.classList.remove('active-cell');
				}
				this.classList.add('active-cell');

				activeCell = this;
			});
		});

		// Event listener for word clicks in the content div
		document.querySelector('.annotation-interface').addEventListener('click', function (e) {
			// Check if the clicked item is a word (or just some space)
			if (e.target === this && activeCell) {
				// Retrieve the clicked word (assuming spaces between words)
				let range = window.getSelection().getRangeAt(0);
				let selectedText = range.toString().trim();

				if (selectedText) {
					activeCell.textContent = selectedText;
				}
			}
		});

		window.addEventListener('click', handleWindowClick);
		// Clean up the event listener when the component is destroyed
		return () => {
			window.removeEventListener('click', handleWindowClick);
		};
	});

	function renderDataOnCanvas(words, dimensions) {
		// const container = document.getElementById('your-image-container'); // Adjust the ID to match your HTML.

		const canvasWidth = canvasElement.offsetWidth;
		const canvasHeight = canvasElement.offsetHeight;

		const imageWidth = dimensions.width;
		const imageHeight = dimensions.height;

		const scaleX = canvasWidth / imageWidth;
		const scaleY = canvasHeight / imageHeight;

		words.forEach((word) => {
			const scaledLeft = word.bbox.left * scaleX;
			const scaledTop = word.bbox.top * scaleY;
			const scaledWidth = word.bbox.width * scaleX;
			const scaledHeight = word.bbox.height * scaleY;

			const box = document.createElement('div');
			box.className = 'ocr-word';
			box.style.left = scaledLeft + 'px';
			box.style.top = scaledTop + 'px';
			box.style.width = scaledWidth + 'px';
			box.style.height = scaledHeight + 'px';

			// Add any other properties or event listeners to the box here, e.g.:
			box.addEventListener('click', (event) => {
				event.stopPropagation();
				showWordTooltip(word, box);
			});

			box.addEventListener('keydown', (event) => {
				if (event.key === 'Enter' || event.key === ' ') {
					event.preventDefault();
					showWordTooltip(word);
				}
			});

			// Update the word's box creation in renderDataOnCanvas
			box.addEventListener('click', (event) => {
				event.stopPropagation();
				handleWordClick(event, word);
			});

			canvasContainer.appendChild(box);
		});
	}

	// function displayOCRText(text) {
	// 	const ocrDisplay = document.querySelector('.ocr-display');
	// 	ocrDisplay.textContent = text;
	// }

	// what are we trying to do here?

	async function processPDF2(file) {
		// fetch request, or axios here
		// ocr/upload file

		try {
			const arrayBuffer = await file.arrayBuffer();
			const loadingTask = pdfjs.getDocument({ data: arrayBuffer });
			const pdf = await loadingTask.promise;
			const page = await pdf.getPage(1);
			const viewport = page.getViewport({ scale });

			if (!canvasElement) {
				throw new Error('Canvas element not found.');
			}

			const dpr = window.devicePixelRatio || 1; // Get device pixel ratio
			canvasElement.width = viewport.width * dpr; // Adjust canvas width
			canvasElement.height = viewport.height * dpr; // Adjust canvas height
			canvasElement.style.width = `${viewport.width}px`; // CSS width to original size
			canvasElement.style.height = `${viewport.height}px`; // CSS height to original size

			const context = canvasElement.getContext('2d');
			context.scale(dpr, dpr); // Scale the drawing context
			context.imageSmoothingEnabled = true;

			canvasElement.height = viewport.height;
			canvasElement.width = viewport.width;

			const renderContext = {
				canvasContext: context,
				viewport
			};

			await page.render(renderContext).promise;

			// Run OCR only if rawWords array is empty
			if (!rawWords.length) {
				let { data: ocrWords, dimensions } = $sessionData;
				rawWords = ocrWords; // Store the raw resultsff
				console.log(rawWords);
				pdfDimensions = dimensions;
				renderDataOnCanvas(rawWords, pdfDimensions);

				// TODO: ENABLE AGAIN IF NECESSARY
				// Assuming 'ocrText' is the variable holding the returned OCR result
				// const ocrText = ocrWords.map((result) => result.text).join(' ');
				// displayOCRText(ocrText);
			}

			// Extract native text from the PDF:
			const textContent = await page.getTextContent();
			nativeWords = textContent.items.map((item) => {
				const transform = item.transform;
				// PDFJS uses transforms to position the text, with six array elements:
				// [scaleX, skewX, skewY, scaleY, translateX, translateY]
				return {
					text: item.str,
					left: transform[4],
					top: transform[5] - transform[3], // Subtracting scaleY to adjust the top position
					width: item.width,
					height: item.height
				};
			});

			// console.log(nativeWords);
		} catch (error) {
			console.error('Error processing PDF and OCR:', error);
			ocrText = 'Error processing document.';
		}
	}

	// let pdfDoc = null;
	let pageNum = 1; // Default page to display is the first one

	// let canvas;
	// let ctx;

	// onMount(() => {
	// 	canvas = document.createElement('canvas');
	// 	ctx = canvas.getContext('2d');
	// 	document.getElementById('pdf-container').appendChild(canvas);
	// });

	let pdfDoc = null; // Global variable to store the loaded PDF document

	async function processPDF(file) {
		try {
			const arrayBuffer = await file.arrayBuffer();
			const loadingTask = pdfjs.getDocument({ data: arrayBuffer });
			pdfDoc = await loadingTask.promise;

			// Optionally, handle OCR and native text extraction here
			// ...

			// Call renderPage for the first page
			renderPage(1);
		} catch (error) {
			console.error('Error processing PDF:', error);
			ocrText = 'Error processing document.';
		}
	}

	async function renderPage(pageNum) {
		if (!pdfDoc) {
			console.error('PDF Document is not loaded');
			return;
		}

		try {
			const page = await pdfDoc.getPage(pageNum);
			const viewport = page.getViewport({ scale });
			const dpr = window.devicePixelRatio || 1;
			canvasElement.width = viewport.width * dpr;
			canvasElement.height = viewport.height * dpr;
			canvasElement.style.width = `${viewport.width}px`;
			canvasElement.style.height = `${viewport.height}px`;

			const context = canvasElement.getContext('2d');
			context.scale(dpr, dpr);
			context.imageSmoothingEnabled = true;

			const renderContext = {
				canvasContext: context,
				viewport
			};

			await page.render(renderContext).promise;

			// Extract text or other data from the page if needed
			// ...
		} catch (error) {
			console.error('Error rendering page:', error);
		}
	}

	// Perhaps I have to pass in the PDF object in for this to work
	function goToPrevPage() {
		if (pdfDoc && pageNum > 1) {
			pageNum--;
			renderPage(pageNum);
		} else {
			console.error('PDF document not loaded or already at the first page');
		}
	}

	function goToNextPage() {
		if (pdfDoc && pageNum < pdfDoc.numPages) {
			pageNum++;
			renderPage(pageNum);
		} else {
			console.error('PDF document not loaded or already at the last page');
		}
	}

	// TODO: set the scale for the bounding boxes
	function setScale(newScale) {
		scale = newScale;
		processPDF(uploadedFile); // Only scales and recalculates bounding boxes
	}

	let selectedWord = null; // This will store the word when clicked

	function showWordTooltip(word, bbox) {
		// Check if a tooltip already exists for this word. If so, remove it.
		const existingTooltip = document.querySelector('.tooltip');
		if (existingTooltip) {
			existingTooltip.remove();
		}

		// Create a new tooltip
		let tooltip = document.createElement('div');
		tooltip.className = 'tooltip';
		tooltip.innerText = word.text; // assuming 'word' has a 'text' property with the word's content

		// Get the position and size of the bbox
		const bboxStyle = window.getComputedStyle(bbox);
		const bboxTop = parseFloat(bboxStyle.top);
		const bboxHeight = parseFloat(bboxStyle.height);

		// Set the position of the tooltip
		tooltip.style.left = bboxStyle.left; // same horizontal position as the bbox
		tooltip.style.top = `${bboxTop + bboxHeight}px`; // below the bbox

		tooltip.style.display = 'block'; // show the tooltip

		// Add the tooltip to the container
		canvasContainer.appendChild(tooltip);
	}

	function handleWindowClick(event) {
		// If the target of the click isn't one of the .ocr-word or .tooltip elements
		if (
			!event.target.classList.contains('ocr-word') &&
			!event.target.classList.contains('tooltip')
		) {
			selectedWord = null; // Hide the tooltip
		}
	}

	let annotations = [];
	let currentAnnotation = null; // { start: null, end: null, label: null }

	let activeCell = null;

	function handleWordClick(event, word) {
		event.stopPropagation();

		// Tooltip Handling
		showWordTooltip(word, event.currentTarget);

		// Annotation Handling
		if (currentAnnotation) {
			currentAnnotation.end = word;
			// showLabelPicker(event.clientX, event.clientY);
		} else {
			currentAnnotation = {
				start: word,
				end: null,
				label: null
			};
		}

		// Active Cell Handling
		if (activeCell) {
			activeCell.textContent = word.text;
		}
	}

	// Save or export the annotations in Spacy's format
	function saveAnnotations() {
		let trainingData = annotations.map((annotation) => {
			let sentence = ocrText;
			let startIdx = sentence.indexOf(annotation.start.text);
			let endIdx = sentence.indexOf(annotation.end.text) + annotation.end.text.length;
			return sentence, { entities: [[startIdx, endIdx, annotation.label]] };
		});

		// Do whatever you want with trainingData, like sending it to your backend or saving it locally
		console.log(trainingData);
	}

	// «««« RESIZE BAR ««««

	// Variables for handling the resizing of containers
	let initialActionBarWidth; // Initial width of the action bar container
	let initialCanvasWidth; // Initial width of the canvas container
	let borderHandle; // The draggable border handle element
	let actionBarContainer; // The action bar container element
	let resizing; // Flag to track the resizing state
	let startX; // X-coordinate of the mouse at the start of resizing

	// Function to handle mouse down event on the border handle
	function onMouseDown(event) {
		resizing = true;
		startX = event.clientX;
		initialActionBarWidth = actionBarContainer.offsetWidth;
		initialCanvasWidth = canvasContainer.offsetWidth;
		window.addEventListener('mousemove', onMouseMove);
		window.addEventListener('mouseup', onMouseUp);
	}

	// Function to handle mouse move event during resizing
	function onMouseMove(event) {
		if (!resizing) return;
		const dx = event.clientX - startX;
		const newActionBarFlexBasis = initialActionBarWidth - dx;
		const newCanvasFlexBasis = initialCanvasWidth + dx;
		actionBarContainer.style.flex = `0 0 ${newActionBarFlexBasis}px`;
		canvasContainer.style.flex = `0 0 ${newCanvasFlexBasis}px`;
	}

	// Function to handle mouse up event, ending the resizing process
	function onMouseUp() {
		resizing = false;
		window.removeEventListener('mousemove', onMouseMove);
		window.removeEventListener('mouseup', onMouseUp);
	}

	let tableHeaders = [
		'HS CODE',
		'Quantity',
		'Net Weight',
		'Gross Weight',
		'Product Description',
		'COO',
		'Unit Price',
		'Total Price'
	];
</script>

<!-- added bind clientWidth and clientHeight for transparency -->
<div id="pdf-container">
	<!-- Paragraph width: {width}px Paragraph height: {height}px -->

	<div
		id="canvas-container"
		bind:this={canvasContainer}
		bind:clientWidth={width}
		bind:clientHeight={height}
	>
		<canvas bind:this={canvasElement} />
		<!-- <input type="file" id="pdf-upload" accept=".pdf" on:change={handleFileChange} />
		<button on:click={toggleResults}>
			{isOCREnabled ? 'Show Native Text' : 'Show OCR Results'}
		</button> -->

		<!-- add javascript - onclick - get next page or previous page
		keep track of all pages that have been rendered/cached
		-->
		<!-- TODO: add on click - 
			store documents, and store multiple documents etc. 
			start there.
			are we storing the whole document here? 
		
		
		-->
		<button
			on:click={() => {
				goToPrevPage(pdfDoc);
			}}
			id="prev">Previous</button
		>
		<button
			on:click={() => {
				goToNextPage(pdfDoc);
			}}
			id="next">Next</button
		>
		<div id="pdf-container" />
	</div>
	<div bind:this={borderHandle} class="border-handle resizable" on:mousedown={onMouseDown} />
	<!-- what is the action bar? -->

	<!-- TODO: get the other table component -->
	<div class="action-bar-container" bind:this={actionBarContainer}>
		<div class="action-bar">
			<div class="content">
				<div class="ocr-display">
					<!-- OCR results will be populated here -->
				</div>
				<div class="annotation-interface">Annotation</div>

				<!-- TODO: Rework this -->
				<div>
					<GenericTable headers={tableHeaders} />
				</div>

				<button on:click={saveAnnotations}>Save Annotations</button>
			</div>
		</div>
	</div>

	<style>
		/* Base Styles */
		#pdf-container {
			display: flex;
			height: 100vh;
			font-family: Open Sans, -apple-system, BlinkMacSystemFont, Segoe UI, Roboto, Oxygen, Ubuntu,
				Cantarell, Fira Sans, Droid Sans, Helvetica Neue, sans-serif;
		}

		/* PDF Viewer */
		#canvas-container {
			min-width: 0;
			flex: 3;
			position: relative;
			overflow: hidden;
		}

		/* Action Bar */
		.action-bar-container {
			min-width: 0;
			display: flex;
			align-items: stretch;
			flex: 2;
		}

		ul {
			list-style-type: none;
			padding: 0;
		}

		canvas {
			border: 1px solid red;
		}

		table {
			width: 100%;
			border-collapse: collapse;
			margin-top: 20px;
			font-size: 12px;
		}

		table,
		th,
		td {
			border: 1px solid #ccc;
		}

		th,
		td {
			padding: 8px 12px;
			text-align: left;
		}

		.active-cell {
			/* background-color: #f5f5f5; */
			/* text-color: var(--text-color); */
		}

		.action-bar {
			display: flex;
			align-items: stretch;
			width: 100%;
			overflow: hidden;
		}

		.content {
			flex: 1;
			overflow-y: auto;
			padding-left: 20px;
			cursor: default;
		}

		/* Your other styles */

		.border-handle {
			width: 22px; /* 10px buffer on each side + 2px for the border itself */
			height: 100%;
			background: linear-gradient(
				to right,
				transparent 10px,
				#ccc 10px,
				#ccc 12px,
				transparent 12px
			); /* 1px border centered */
			cursor: default; /* default cursor for the handle area */
			position: relative;
			z-index: 100;
		}

		/* Hover effect only on the border itself */
		.border-handle:hover {
			background: linear-gradient(
				to right,
				transparent 10px,
				rgb(42, 91, 252) 10px,
				rgb(42, 91, 252) 12px,
				transparent 12px
			);
			cursor: ew-resize;
		}

		/* Cursor effect only on the border */
		.border-handle::before,
		.border-handle::after {
			content: '';
			position: absolute;
			top: 0;
			bottom: 0;
			width: 10px;
			z-index: 10;
			cursor: ew-resize; /* Resize cursor only over the sides of the border */
		}

		.border-handle::before {
			left: 0;
		}

		.border-handle::after {
			right: 0;
		}

		/* Your other styles */

		/* OCR Results */
		#ocr-results {
			flex-basis: 250px;
			overflow-y: auto;
			padding-left: 20px;
			border-left: 1px solid #ccc;
		}

		.ocr-word {
			position: absolute;
			border: 2px solid transparent;
			transition: border 0.3s ease;
			z-index: 99;
		}

		.ocr-word:hover {
			border: 2px solid blue;
			cursor: pointer;
		}

		/* Tooltip */
		.tooltip {
			position: absolute;
			padding: 5px 10px;
			background-color: #000;
			color: #fff;
			border-radius: 4px;
			pointer-events: none;
			transform: translateY(5px);
			font-size: 14px;
			z-index: 10;
		}
	</style>
</div>
